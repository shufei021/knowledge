import{_ as e,c as t,o as s,ae as r}from"./chunks/framework.BkDzuGyC.js";const c=JSON.parse('{"title":"Vue 的路由实现原理","description":"","frontmatter":{},"headers":[],"relativePath":"guide/d/p11.md","filePath":"guide/d/p11.md"}'),o={name:"guide/d/p11.md"};function p(i,a,h,d,l,u){return s(),t("div",null,a[0]||(a[0]=[r('<h1 id="vue-的路由实现原理" tabindex="-1">Vue 的路由实现原理 <a class="header-anchor" href="#vue-的路由实现原理" aria-label="Permalink to &quot;Vue 的路由实现原理&quot;">​</a></h1><details class="details custom-block" open=""><summary>Details</summary><p>核心是通过改变 URL 而不刷新页面，实现组件的切换渲染</p><p>Hash 模式利用 URL 中的哈希变化 + hashchange事件加监听</p><p>History 模式利用 HTML5 的 pushState、replaceState + popstate事件监听</p></details><p>Vue 的路由实现原理主要基于两种模式，核心是通过改变 URL 而不刷新页面，实现组件的切换渲染：</p><h2 id="hash-模式" tabindex="-1">Hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;Hash 模式&quot;">​</a></h2><p>利用 URL 中的哈希（#后面的部分）变化触发路由跳转。哈希变化不会向服务器发送请求，且会触发hashchange事件，Vue Router 监听该事件，匹配对应的路由规则，渲染相应组件。</p><h2 id="history-模式" tabindex="-1">History 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;History 模式&quot;">​</a></h2><p>基于 HTML5 的history对象 API（如pushState、replaceState），通过修改 URL 的路径部分（无#）实现跳转。这些 API 能改变 URL 而不触发页面刷新，Vue Router 监听popstate事件（如浏览器前进 / 后退），并结合路由配置匹配组件。</p><p>两种模式的核心逻辑一致：拦截 URL 变化→匹配路由规则→渲染对应组件，从而实现单页应用（SPA）的无刷新页面切换。</p>',8)]))}const _=e(o,[["render",p]]);export{c as __pageData,_ as default};
