import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.BkDzuGyC.js";const c=JSON.parse('{"title":"toRefs 和 toRaw 区别","description":"","frontmatter":{},"headers":[],"relativePath":"guide/d/p16.md","filePath":"guide/d/p16.md"}'),n={name:"guide/d/p16.md"};function l(p,s,h,o,k,r){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="torefs-和-toraw-区别" tabindex="-1">toRefs 和 toRaw 区别 <a class="header-anchor" href="#torefs-和-toraw-区别" aria-label="Permalink to &quot;toRefs 和 toRaw 区别&quot;">​</a></h1><details class="details custom-block" open=""><summary>Details</summary><p><code>toRefs</code> 用于<code>解构响应式对象</code>并<code>保持响应性</code>，<code>toRaw</code> 用于<code>获取原始数据</code>，<code>跳过响应式</code>。</p></details><p>在 Vue 3 中，<code>toRefs</code> 和 <code>toRaw</code> 是两个不同的函数，它们各自有不同的用途和功能。以下是简答的区别说明：</p><h3 id="📌-torefs" tabindex="-1">📌 <code>toRefs</code> <a class="header-anchor" href="#📌-torefs" aria-label="Permalink to &quot;📌 \`toRefs\`&quot;">​</a></h3><ul><li><strong>作用</strong>：将响应式对象（由 <code>reactive</code> 创建）转换为普通对象，其中每个属性都是指向原始响应式对象相应属性的 <code>ref</code>。</li><li><strong>使用场景</strong>：当你需要解构或传递响应式对象的属性时，使用 <code>toRefs</code> 可以确保这些属性仍然是响应式的。</li><li><strong>示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { reactive, toRefs } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  version: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stateAsRefs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 现在 stateAsRefs.name 和 stateAsRefs.version 都是 ref 类型，并且保持响应性</span></span></code></pre></div></li></ul><h3 id="📌-toraw" tabindex="-1">📌 <code>toRaw</code> <a class="header-anchor" href="#📌-toraw" aria-label="Permalink to &quot;📌 \`toRaw\`&quot;">​</a></h3><ul><li><strong>作用</strong>：返回由 <code>reactive</code> 或 <code>readonly</code> 方法创建的代理对象的原始对象。它可以帮助你绕过 Vue 的响应式系统直接操作原始数据。</li><li><strong>使用场景</strong>：主要用于调试、性能优化等场景下，当你需要访问原始对象而不是它的响应式代理版本时。</li><li><strong>示例</strong>：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { reactive, toRaw } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  version: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> originalState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRaw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// originalState 是原始对象，不是响应式代理</span></span></code></pre></div></li></ul><h3 id="📝-总结" tabindex="-1">📝 总结 <a class="header-anchor" href="#📝-总结" aria-label="Permalink to &quot;📝 总结&quot;">​</a></h3><ul><li><strong><code>toRefs</code></strong>：用于将响应式对象的所有属性转化为独立的 <code>ref</code>，以便在解构或传递时保持其响应性。</li><li><strong><code>toRaw</code></strong>：用于获取一个响应式对象的原始对象，跳过 Vue 的响应式系统，适用于特定场景下的调试或优化。</li></ul><p>希望这个简短的解释能帮助你在面试中清晰地回答关于 <code>toRefs</code> 和 <code>toRaw</code> 的区别！如果有更多问题或需要进一步解释，请随时告诉我。</p>`,10)]))}const g=i(n,[["render",l]]);export{c as __pageData,g as default};
