import{_ as a,c as t,o,ae as r}from"./chunks/framework.BkDzuGyC.js";const p=JSON.parse('{"title":"vue的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"guide/d/p1.md","filePath":"guide/d/p1.md"}'),d={name:"guide/d/p1.md"};function n(i,e,c,s,u,l){return o(),t("div",null,e[0]||(e[0]=[r('<h1 id="vue的生命周期" tabindex="-1">vue的生命周期 <a class="header-anchor" href="#vue的生命周期" aria-label="Permalink to &quot;vue的生命周期&quot;">​</a></h1><h2 id="beforecreate" tabindex="-1"><code>beforeCreate</code> <a class="header-anchor" href="#beforecreate" aria-label="Permalink to &quot;`beforeCreate`&quot;">​</a></h2><p><strong>这个钩子在实例初始化之后、数据观测 (data observer) 和 event/watcher 事件配置之前被调用</strong>,不过，在 Composition API 中，通常使用 setup() 函数来处理这一阶段的逻辑，因此这个钩子不常用。</p><h2 id="created" tabindex="-1"><code>created</code> <a class="header-anchor" href="#created" aria-label="Permalink to &quot;`created`&quot;">​</a></h2><p><strong>在实例创建完成后立即调用</strong>。在这个阶段，实例已经完成了数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。但是，挂载阶段还没开始，$el 属性目前不可见</p><h2 id="beforemount" tabindex="-1"><code>beforeMount</code> <a class="header-anchor" href="#beforemount" aria-label="Permalink to &quot;`beforeMount`&quot;">​</a></h2><p><strong>在挂载开始之前被调用</strong>：相关的 render 函数首次被调用。此时，虚拟 DOM 尚未渲染到真实 DOM 上</p><h2 id="mounted" tabindex="-1"><code>mounted</code> <a class="header-anchor" href="#mounted" aria-label="Permalink to &quot;`mounted`&quot;">​</a></h2><p><strong>在 el 被新创建的 vm.$el 替换，并挂载到实例上后调用</strong>。这时，组件已经被渲染到 DOM 中，可以访问 DOM 元素了。</p><h2 id="beforeupdate" tabindex="-1"><code>beforeUpdate</code> <a class="header-anchor" href="#beforeupdate" aria-label="Permalink to &quot;`beforeUpdate`&quot;">​</a></h2><p><strong>在数据更新时，在虚拟 DOM 打补丁之前调用</strong>。此时，可以获取更新前的状态，适合用来进行一些清理工作。</p><h2 id="updated" tabindex="-1"><code>updated</code> <a class="header-anchor" href="#updated" aria-label="Permalink to &quot;`updated`&quot;">​</a></h2><p><strong>在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用</strong>。此时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。然而，避免在此期间改变状态，因为这可能会导致无限的更新循环</p><h2 id="beforeunmount-在-vue-2-中为-beforedestroy" tabindex="-1"><code>beforeUnmount（在 Vue 2 中为 beforeDestroy）</code> <a class="header-anchor" href="#beforeunmount-在-vue-2-中为-beforedestroy" aria-label="Permalink to &quot;`beforeUnmount（在 Vue 2 中为 beforeDestroy）`&quot;">​</a></h2><p><strong>发生在实例销毁之前，在当前阶段实例完全可以被使用</strong>。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。</p><h2 id="unmounted-在-vue-2-中为-destroyed" tabindex="-1"><code>unmounted（在 Vue 2 中为 destroyed）</code> <a class="header-anchor" href="#unmounted-在-vue-2-中为-destroyed" aria-label="Permalink to &quot;`unmounted（在 Vue 2 中为 destroyed）`&quot;">​</a></h2><p><strong>卸载组件实例后调用</strong>。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。</p><p><strong>activated 和 deactivated 是 Vue 中专门用于 &lt; keep-alive&gt; 缓存组件时的生命周期钩子</strong></p><h2 id="activated-keep-alive" tabindex="-1"><code>activated(keep-alive)</code> <a class="header-anchor" href="#activated-keep-alive" aria-label="Permalink to &quot;`activated(keep-alive)`&quot;">​</a></h2><p><strong>当组件被 &lt; keep-alive&gt; 缓存后，每次该组件被激活（显示）时调用</strong>。可以在这里执行组件重新展示时需要的逻辑，比如重新获取数据、恢复动画、计时器等</p><h2 id="deactivated-keep-alive" tabindex="-1"><code>deactivated(keep-alive)</code> <a class="header-anchor" href="#deactivated-keep-alive" aria-label="Permalink to &quot;`deactivated(keep-alive)`&quot;">​</a></h2><p><strong>当组件被缓存后，离开当前视图（被切换出去）时调用</strong>。可以在这里进行一些资源释放操作，比如清除定时器、取消事件监听、停止动画等，防止内存泄漏。</p>',22)]))}const b=a(d,[["render",n]]);export{p as __pageData,b as default};
