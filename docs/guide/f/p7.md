# 搭建 Qiankun 微前端项目的详细指南

## 一、准备工作

### 1. 确定技术栈
确定主应用和子应用使用的技术栈（React/Vue/Angular/原生JS等）

### 2. 安装依赖
```bash
# 创建项目目录
mkdir qiankun-demo
cd qiankun-demo

# 初始化 package.json
npm init -y

# 安装 qiankun
npm install qiankun --save
```

## 二、创建主应用

### 1. 安装主应用框架（以React为例）
```bash
npx create-react-app main-app
cd main-app
npm install --save qiankun
```

### 2. 配置主应用

#### 修改 `src/index.js`
```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { registerMicroApps, start } from 'qiankun';

// 渲染主应用
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);

// 注册子应用
registerMicroApps(
  [
    {
      name: 'vue-app', // 子应用名称
      entry: '//localhost:7101', // 子应用入口
      container: '#subapp-viewport', // 子应用容器节点
      activeRule: '/vue', // 子应用激活规则
    },
    {
      name: 'react-app', // 子应用名称
      entry: '//localhost:7102', // 子应用入口
      container: '#subapp-viewport', // 子应用容器节点
      activeRule: '/react', // 子应用激活规则
    }
  ],
  {
    beforeLoad: [async (app) => console.log('Before load: ', app)],
    beforeMount: [async (app) => console.log('Before mount: ', app)]
  }
);

// 启动 qiankun
start({ prefetch: 'all' });
```

#### 修改 `src/App.js`
```javascript
import React from 'react';

function App() {
  return (
    <div>
      <h1>主应用</h1>
      <nav>
        <a href="/vue">Vue 子应用</a>
        <a href="/react">React 子应用</a>
      </nav>
      <div id="subapp-viewport"></div> {/* 子应用容器 */}
    </div>
  );
}

export default App;
```

### 3. 配置主应用打包（以React为例）

#### 修改 `config/webpack.config.js`（需要先执行 `npm run eject`）
```javascript
// 在 output 配置中添加
output: {
  ...
  library: 'mainApp',
  libraryTarget: 'umd',
  jsonpFunction: `webpackJsonp_main_app`,
},
```

## 三、创建子应用

### 1. 创建 Vue 子应用
```bash
# 创建 Vue 子应用
vue create vue-app
cd vue-app
npm install --save qiankun
```

#### 修改 `src/main.js`
```javascript
import Vue from 'vue';
import App from './App.vue';
import { setDefaultMountApp, start } from 'qiankun';

Vue.config.productionTip = false;

// 开发环境单独运行时
if (!window.qiankun) {
  new Vue({
    render: h => h(App)
  }).$mount('#app');
}

// qiankun 生命周期
export async function bootstrap() {
  console.log('vue app bootstraped');
}

export async function mount(props) {
  console.log('props from main app', props);
  new Vue({
    render: h => h(App)
  }).$mount('#app');
}

export async function unmount() {
  // Vue instance destroy
}

// 开启 qiankun
start();
```

#### 修改 `vue.config.js`
```javascript
module.exports = {
  devServer: {
    port: 7101,
    headers: {
      'Access-Control-Allow-Origin': '*',
    },
  },
  configureWebpack: {
    output: {
      library: 'vueApp',
      libraryTarget: 'umd',
    },
  },
};
```

### 2. 创建 React 子应用
```bash
# 创建 React 子应用
npx create-react-app react-app
cd react-app
npm install --save qiankun
```

#### 修改 `src/main.js`
```javascript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

// 开发环境单独运行时
if (!window.qiankun) {
  ReactDOM.render(<App />, document.getElementById('root'));
}

// qiankun 生命周期
export async function bootstrap() {
  console.log('react app bootstraped');
}

export async function mount(props) {
  console.log('props from main app', props);
  ReactDOM.render(<App />, props.container ? props.container.querySelector('#root') : document.getElementById('root'));
}

export async function unmount() {
  ReactDOM.unmountComponentAtNode(document.getElementById('root'));
}
```

#### 修改 `src/index.js`
```javascript
import './main';
```

#### 修改 `config/webpack.config.js`（需要先执行 `npm run eject`）
```javascript
// 在 output 配置中添加
output: {
  ...
  library: 'reactApp',
  libraryTarget: 'umd',
  jsonpFunction: `webpackJsonp_react_app`,
},
```

#### 修改 `package.json`
```json
{
  ...
  "homepage": "http://localhost:7102",
  ...
}
```

## 四、启动项目

### 1. 启动子应用
```bash
# 启动 Vue 子应用
cd vue-app
npm run serve

# 启动 React 子应用
cd react-app
npm start
```

### 2. 启动主应用
```bash
cd main-app
npm start
```

## 五、关键配置和注意事项

### 1. 子应用生命周期
```javascript
// bootstrap：在微前端环境中只会在应用初始化时执行一次
export async function bootstrap() {
  console.log('app bootstraped');
}

// mount：每次应用被加载时都会执行
export async function mount(props) {
  console.log('app mounted', props);
  // 推荐将子应用的渲染操作放在这里
}

// unmount：每次应用被卸载时都会执行
export async function unmount() {
  console.log('app unmounted');
  // 推荐在这里执行清理操作
}
```

### 2. 路由配置
- 确保主应用和子应用的路由规则不冲突
- 子应用的路由应使用相对路径
- 推荐主应用使用 BrowserRouter，子应用使用 HashRouter

### 3. 样式隔离
- 使用 iframe 模式：完全隔离，但通信复杂
- 使用沙箱模式：实验性功能，可能影响性能
- 最佳实践：
  - 统一 CSS 命名规范（如添加前缀）
  - 使用 Shadow DOM
  - 使用 CSS Modules 或 CSS-in-JS 方案

### 4. 数据通信
```javascript
// 主应用向子应用传参
registerMicroApps([
  {
    name: 'app',
    entry: '//localhost:7101',
    container: '#subapp-viewport',
    activeRule: '/app',
    props: {
      message: 'Hello from main app'
    }
  }
]);

// 子应用接收参数
export async function mount(props) {
  console.log(props.message); // Hello from main app
}

// 使用全局状态管理
import { initGlobalState, MicroAppStateActions } from 'qiankun';

const { onGlobalStateChange, setGlobalState } = initGlobalState({
  user: 'qiankun',
});

onGlobalStateChange((state, prev) => {
  // state: 变更后的状态, prev 变更前的状态
});

setGlobalState(state); // 设置全局状态
```

### 5. 公共资源处理
- 将公共库（如 react、vue）设置为 externals
- 使用 import-html-entry 提供的 fetch 方法加载公共资源
- 配置 webpack externals
```javascript
// webpack.config.js
externals: {
  react: 'React',
  'react-dom': 'ReactDOM',
}
```

### 6. 性能优化
- 使用 prefetch: 'all' 预加载子应用资源
- 使用懒加载按需加载子应用
- 配置合理的加载超时时间
```javascript
start({
  prefetch: 'all',
  sandbox: {
    experimentalStyleIsolation: true, // 实验性样式隔离
  },
  singular: false, // 支持多实例
  fetch: async (url, ...args) => {
    if (url.endsWith('.js')) {
      // 自定义 js 加载逻辑
    }
    return fetch(url, ...args);
  }
});
```

### 7. 错误处理
```javascript
start({
  beforeLoad: [
    async (app) => {
      console.log('Before load: ', app);
      // 可以在这里进行加载前的检查
    }
  ],
  beforeMount: [
    async (app) => {
      try {
        // 挂载前的准备
        return Promise.resolve();
      } catch (error) {
        console.error('挂载失败', error);
        return Promise.reject(error);
      }
    }
  ]
});
```

### 8. 安全策略
- 配置 Content Security Policy (CSP)
- 使用沙箱环境防止脚本注入
- 对子应用资源进行校验
```javascript
start({
  sandbox: {
    experimentalStyleIsolation: true, // 实验性样式隔离
    snapshot: true, // 开启沙箱快照
  },
  ignoreInstantiateWarning: true, // 忽略不安全的脚本警告
});
```

## 六、部署注意事项

1. 确保子应用支持跨域访问
2. 配置合适的 Content-Security-Policy
3. 子应用需要支持路由的 history 模式
4. 静态资源路径要正确配置
5. 避免全局样式污染
6. 生产环境建议开启沙箱模式

## 七、常见问题排查

1. **子应用空白**：
   - 检查容器节点是否存在
   - 检查子应用是否正确导出生命周期钩子
   - 查看浏览器控制台是否有错误

2. **样式冲突**：
   - 检查是否开启了样式隔离
   - 检查 CSS 命名是否冲突
   - 使用浏览器开发者工具检查元素样式

3. **找不到子应用节点**：
   - 确保子应用容器在 DOM 加载完成后才创建
   - 使用 document.querySelector 验证节点是否存在

4. **子应用加载失败**：
   - 检查网络请求是否正常
   - 检查子应用是否配置了正确的 CORS 头
   - 检查子应用是否正确打包

5. **子应用卸载后无法重新加载**：
   - 检查 unmount 钩子是否正确清理了资源
   - 检查是否需要重新创建 DOM 节点

6. **子应用样式未生效**：
   - 检查是否使用了 CSS Modules 或 CSS-in-JS
   - 检查样式加载顺序
   - 检查是否开启了样式隔离

## 八、进阶配置

1. **动态注册子应用**
```javascript
let apps = [
  { name: 'app1', entry: '//localhost:7101', container: '#subapp-viewport', activeRule: '/app1' }
];

// 动态添加子应用
function addApp(newApp) {
  apps.push(newApp);
  registerMicroApps(apps);
}
```

2. **自定义加载器**
```javascript
start({
  loadComponent: async (url) => {
    // 自定义组件加载逻辑
    const response = await fetch(url);
    return response.json();
  }
});
```

3. **子应用保活**
```javascript
start({
  keepAlive: true // 实验性功能
});
```

4. **自定义 fetch**
```javascript
start({
  fetch: async (url, options) => {
    // 添加自定义请求头
    const newOptions = {
      ...options,
      headers: {
        ...options.headers,
        'X-Qiankun': '1',
      }
    };
    return fetch(url, newOptions);
  }
});
```

5. **性能监控**
```javascript
start({
  beforeLoad: [
    async (app) => {
      window.appLoadStartTime = Date.now();
    }
  ],
  beforeMount: [
    async (app) => {
      console.log(`应用加载耗时: ${Date.now() - window.appLoadStartTime}ms`);
    }
  ]
});
```

在使用 Qiankun 框架时，主应用通过注册微应用并配置相应的生命周期钩子来管理微应用。以下是关于如何注册微应用、传递数据给微应用、支持的微应用类型以及主应用和微应用之间的通信机制的详细说明：

### 注册微应用

在主应用中注册微应用通常是在主应用初始化时完成的。你需要使用 `registerMicroApps` 方法来注册你的微应用，并指定每个微应用的相关信息，包括名称、入口地址、容器节点以及激活规则等。

```javascript
import { registerMicroApps, start } from 'qiankun';

registerMicroApps(
  [
    {
      name: 'reactApp', // 微应用名称
      entry: '//localhost:3000', // 微应用的入口地址
      container: '#container', // 容器节点的选择器
      activeRule: '/app-vue', // 激活微应用的路由规则
      props: { msg: "我是来自主应用的值" }, // 向微应用传递的数据
    },
    // 可以继续添加其他微应用
  ],
  {
    beforeLoad: app => console.log('before load', app.name),
    beforeMount: [...],
    afterMount: [...],
    beforeUnmount: [...],
    afterUnmount: [...],
  }
);

start();
```

### 传递数据给微应用

Qiankun 支持通过 `props` 属性向微应用传递数据。当微应用被挂载时，这些数据会作为参数传递给微应用的 `mount` 生命周期函数。

在微应用端，你可以这样接收主应用传来的数据：

```javascript
export async function mount(props) {
  console.log(props.msg); // 输出：我是来自主应用的值
}
```

### 支持的微应用类型

Qiankun 是技术栈无关的，这意味着它可以与任何前端框架或库一起工作，如 React、Vue、Angular 等。只要微应用能够导出特定的生命周期钩子（`bootstrap`、`mount` 和 `unmount`），就可以被 Qiankun 加载。

### 数据通信和改变的桥梁

Qiankun 提供了多种方式来进行主应用和微应用之间的通信：

1. **Props 传递**：这是最直接的方式，适用于从主应用向微应用传递静态数据。
2. **全局状态管理**：Qiankun 提供了一个简单的发布订阅模式来实现应用间的状态共享。你可以使用 `initGlobalState` 来创建一个全局状态对象，并在各个应用中监听这个状态的变化。
   
   在主应用中：
   ```javascript
   import { initGlobalState } from 'qiankun';
   
   const initialState = {};
   const actions = initGlobalState(initialState);
   
   actions.onGlobalStateChange((state, prev) => {
     // state: 变更后的状态; prev 变更前的状态
   });
   
   actions.setGlobalState(newState);
   ```

   在微应用中：
   ```javascript
   export async function bootstrap() {}
   
   export async function mount(props) {
     props.onGlobalStateChange((state, prev) => {
       // 监听全局状态变化
     });
     
     props.setGlobalState({ user: 'newUser' }); // 修改全局状态
   }
   
   export async function unmount() {}
   ```
   
3. **自定义事件**：你也可以通过原生的 DOM 事件或者第三方库（如 mitt）来实现在不同应用之间发送和接收消息。


### 在微应用中触发主应用的方法

要在微应用中触发主应用的方法，可以通过 Qiankun 提供的全局状态管理机制或直接通过 props 传递回调函数这两种方式实现。

#### 1. 使用全局状态管理
Qiankun 的全局状态管理允许微应用和主应用之间共享状态，并监听状态的变化。你可以利用这个特性来在微应用中改变某个状态，从而间接地“通知”主应用执行特定的操作。

首先，在主应用中初始化全局状态并定义需要暴露给微应用的方法：

```javascript
import { initGlobalState, MicroAppStateActions } from 'qiankun';

// 初始化全局状态
const initialState = {};
const actions: MicroAppStateActions = initGlobalState(initialState);

actions.onGlobalStateChange((state, prev) => {
  // 监听全局状态变化
  if (state.someAction === 'doSomething') {
    doSomething();
  }
});

export const doSomething = () => {
  console.log('Doing something in main app!');
};

// 将 actions 暴露给注册的微应用
registerMicroApps(
  [
    // 微应用配置...
  ],
  {
    beforeMount: [
      (app) => {
        app.props = actions;
      },
    ],
  }
);
```

然后，在微应用中使用这些方法：

```javascript
export async function mount(props) {
  props.onGlobalStateChange((state, prev) => {
    // 监听全局状态变化
  });

  // 触发主应用的方法
  props.setGlobalState({ someAction: 'doSomething' });
}
```

#### 2. 通过 Props 传递回调函数
你也可以直接通过 `props` 向微应用传递一个回调函数，当需要调用主应用的方法时，微应用可以直接调用这个回调函数。

在主应用注册微应用时，通过 `props` 传递回调函数：

```javascript
registerMicroApps(
  [
    {
      name: 'subApp',
      entry: '//localhost:7101',
      container: '#subapp-viewport',
      activeRule: '/sub-app',
      props: {
        onTrigger: () => {
          console.log('Method triggered from sub app');
        }
      }
    }
  ]
);
```

在微应用中调用这个回调函数：

```javascript
export async function mount(props) {
  // 调用主应用的方法
  props.onTrigger();
}
```

### 全局状态管理的实现原理

Qiankun 的全局状态管理基于发布/订阅模式（Pub/Sub），它允许不同的应用（无论是主应用还是微应用）能够订阅全局状态的变化，并且可以发布新的状态更新。这种方式非常适合用于处理跨应用的状态同步问题。

#### 实现细节

1. **初始化全局状态**：使用 `initGlobalState` 函数初始化一个全局状态对象。这将返回一个包含 `onGlobalStateChange`, `setGlobalState`, 和其他必要方法的对象。
   
   ```javascript
   import { initGlobalState } from 'qiankun';
   
   const initialState = { user: 'defaultUser' };
   const actions = initGlobalState(initialState);
   ```

2. **监听状态变化**：通过 `onGlobalStateChange` 方法注册一个监听器，每当全局状态发生变化时，都会触发该监听器。
   
   ```javascript
   actions.onGlobalStateChange((state, prev) => {
     console.log('State changed from', prev, 'to', state);
   });
   ```

3. **设置全局状态**：任何应用都可以使用 `setGlobalState` 方法来更新全局状态。一旦状态被更新，所有注册的监听器都会收到通知。
   
   ```javascript
   actions.setGlobalState({ user: 'newUser' });
   ```

4. **共享状态与方法**：通过在主应用中初始化全局状态，并将生成的 `actions` 对象作为 `props` 传递给微应用，微应用就可以访问到主应用中定义的方法以及全局状态。

这种设计使得主应用和微应用可以在不直接相互引用的情况下进行通信，极大地提高了系统的灵活性和模块化程度。同时，由于状态的管理和同步是集中式的，因此也便于维护和调试。