
# ref 和 reactive 的区别

::: details {open}
`ref` 用于创建单一值的响应式引用，需通过 `.value` 操作；

`reactive` 则用于`创建复杂对象的响应式代理`，`直接操作属性`即可。
:::

在 Vue 3 中，`ref` 和 `reactive` 是 Composition API 提供的两个核心响应式函数，它们用于创建不同类型的响应式数据。

#### `ref`

- **定义**：`ref` 用于创建一个包含值的响应式引用对象。这个引用对象是一个容器，它有一个 `.value` 属性来存取实际的值。
  
- **适用场景**：适用于基本类型数据（如字符串、数字等）或需要跨组件层级传递的数据。由于 `ref` 返回的是一个对象，因此它可以很好地处理 JavaScript 的值传递机制，尤其是在函数参数和返回值中使用时。

- **用法示例**：
    ```javascript
    import { ref } from 'vue';
    
    const count = ref(0);
    console.log(count.value); // 输出: 0
    count.value++;
    ```

#### `reactive`

- **定义**：`reactive` 接受一个普通对象然后返回该普通对象的响应式代理。本质上是对对象进行深度监听，使对象中的所有属性都成为响应式的。

- **适用场景**：最适合于复杂的数据结构，比如对象或者数组。当你需要对整个对象进行响应式追踪而不是单一值时，`reactive` 是更合适的选择。

- **用法示例**：
    ```javascript
    import { reactive } from 'vue';
    
    const state = reactive({
      count: 0
    });
    console.log(state.count); // 输出: 0
    state.count++;
    ```

#### 主要区别

1. **数据类型**：`ref` 可以用来包装任何类型的值，包括原始类型和对象；而 `reactive` 主要用于对象（包括数组和集合），不能直接应用于原始类型。

2. **访问方式**：`ref` 创建的数据需要通过 `.value` 来访问或修改其值；而 `reactive` 直接操作对象属性即可，不需要额外的语法。

3. **解构与传播**：解构 `reactive` 对象不会保持响应性，而 `ref` 在某些情况下可以通过解构保持响应性（例如在 `<script setup>` 中自动解开）。此外，`ref` 可以作为 prop 传递并在子组件中使用 `.value` 访问，这使得它非常适合用于组件间通信。

4. **性能考虑**：由于 `reactive` 对对象的所有嵌套层次进行深度监听，可能会带来一定的性能开销；相比之下，`ref` 只监听顶层的值变化，可能在特定场景下提供更好的性能表现。

理解何时使用 `ref` 和 `reactive` 是掌握 Vue 3 Composition API 的关键之一。根据你的具体需求选择合适的工具可以让你的应用更加高效且易于维护。
#### 实现原理
在 Vue 3 中，`ref` 和 `reactive` 是 Composition API 的两个重要函数，用于创建响应式数据。它们的底层实现基于 ES6 的 `Proxy` 对象，但各自有不同的机制来实现响应式行为。

#### `reactive` 的底层实现原理

- **Proxy 对象**：`reactive` 函数通过将传入的对象转换为一个 `Proxy` 对象来实现响应式。`Proxy` 可以拦截对对象的基本操作（如获取属性、设置属性等），这使得 Vue 能够追踪依赖并在状态改变时通知相关的视图进行更新。
  
- **深度响应**：使用 `reactive` 创建的对象是深度响应式的，这意味着它会递归地将所有嵌套的对象都转换为 `Proxy` 对象，确保任何层级的变化都能被检测到并触发更新。

- **陷阱（Traps）**：`Proxy` 使用了多种陷阱（如 `get`, `set`, `deleteProperty` 等）来定义当执行这些操作时的行为。例如，在 `get` 操作中收集依赖，在 `set` 操作中触发更新。

##### `ref` 的底层实现原理

- **封装基本值**：与 `reactive` 不同，`ref` 主要用于包装基本数据类型（虽然也可以包装对象）。它返回的是一个包含 `.value` 属性的对象，这个对象本身不是响应式的，但其 `.value` 属性是响应式的。

- **触发更新**：当你修改 `ref` 包装的值（即修改 `.value` 属性）时，Vue 会检测到这一变化，并触发相应的更新。对于基本数据类型的 `ref`，Vue 通过访问器属性（getter 和 setter）来追踪变化。

- **自动解包**：在模板和某些特定的反应式上下文中（比如计算属性或侦听器），Vue 会自动解包 `ref`，使其可以直接使用而不需要显式地通过 `.value` 访问。但是，在 JavaScript 代码内部使用时，仍然需要手动访问 `.value`。

##### 总结

- **`reactive`** 利用 `Proxy` 提供深层次的响应式对象，适用于复杂的数据结构。
- **`ref`** 更加灵活，可以包装任意类型的值，特别是基本数据类型，并且通过访问器属性实现响应性。

两者都是 Vue 响应式系统的重要组成部分，但根据不同的需求选择合适的工具可以使你的应用更加高效和易于维护。 
