
# 自定义指令
在 Vue 3 中，自定义指令提供了一种强大的方式来直接操作 DOM 或添加特定的行为到元素上。它们是 Vue 提供的一种扩展机制，允许开发者根据需要定制组件的行为或外观。下面简要介绍 Vue 3 自定义指令的基本概念和使用方法。

## 🌟 自定义指令的基础

Vue 3 中的自定义指令与 Vue 2 类似，但有一些更新和改进。你可以通过 `app.directive` 方法注册全局指令，或者通过组件选项 `directives` 注册局部指令。

## ✅ 自定义指令钩子函数

自定义指令的核心在于它提供的几个生命周期钩子函数，这些钩子会在不同阶段被调用：

- **beforeMount**: 当指令第一次绑定到元素时调用，并且只调用一次。
- **mounted**: 元素插入父节点时调用（这可能发生在 `beforeMount` 之后立即发生，也可能发生在以后）。
- **beforeUpdate**: 在包含组件的 VNode 更新之前调用，但是它还没有重新渲染于 DOM 上。
- **updated**: 在包含组件的 VNode 及其子组件的 VNode 都更新后调用。
- **beforeUnmount**: 指令解绑前调用。
- **unmounted**: 指令解绑时调用，这时移除任何相关的事件监听器或清理工作。

## ✅ 创建一个简单的自定义指令

以下是一个简单的例子，展示如何创建一个聚焦输入框的自定义指令：

```javascript
// 注册全局自定义指令
app.directive('focus', {
  mounted(el) {
    el.focus();
  }
});
```

使用这个指令：

```vue
<template>
  <input v-focus />
</template>
```

这段代码会在页面加载时自动聚焦到输入框。

## ✅ 参数说明

每个钩子函数都会接收以下参数：

1. **el**：应用该指令的元素。
2. **binding**：包含以下属性的对象：
   - **value**：传递给指令的值。
   - **oldValue**：之前的值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变，它都可用。
   - **arg**：传给指令的参数 (如果有的话)。
   - **modifiers**：一个对象，包含了所有修饰符 (如果有的话)。
3. **vnode**：Vue 编译生成的虚拟节点。
4. **prevVnode**：上一个虚拟节点，在 `update` 和 `componentUpdated` 钩子中可用。

## ✅ 示例：带参数和修饰符的自定义指令

假设我们想创建一个点击外部关闭某个元素的指令：

```javascript
app.directive('click-outside', {
  beforeMount(el, binding) {
    el.__ClickOutsideHandler__ = function(event) {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.body.addEventListener('click', el.__ClickOutsideHandler__);
  },
  unmounted(el) {
    document.body.removeEventListener('click', el.__ClickOutsideHandler__);
  }
});
```

使用示例：

```vue
<template>
  <div v-click-outside="closeMenu">
    <!-- 菜单内容 -->
  </div>
</template>

<script>
export default {
  methods: {
    closeMenu() {
      console.log('关闭菜单');
    }
  }
};
</script>
```

在这个例子中，当用户点击了 div 外部的任何地方时，`closeMenu` 方法将被调用。


