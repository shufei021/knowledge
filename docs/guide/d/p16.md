# toRefs 和 toRaw 区别

::: details {open}
`toRefs` 用于`解构响应式对象`并`保持响应性`，`toRaw` 用于`获取原始数据`，`跳过响应式`。
:::



在 Vue 3 中，`toRefs` 和 `toRaw` 是两个不同的函数，它们各自有不同的用途和功能。以下是简答的区别说明：

### 📌 `toRefs`

- **作用**：将响应式对象（由 `reactive` 创建）转换为普通对象，其中每个属性都是指向原始响应式对象相应属性的 `ref`。
- **使用场景**：当你需要解构或传递响应式对象的属性时，使用 `toRefs` 可以确保这些属性仍然是响应式的。
- **示例**：
  ```javascript
  import { reactive, toRefs } from 'vue';

  const state = reactive({
    name: 'Vue',
    version: 3
  });

  const stateAsRefs = toRefs(state);
  // 现在 stateAsRefs.name 和 stateAsRefs.version 都是 ref 类型，并且保持响应性
  ```

### 📌 `toRaw`

- **作用**：返回由 `reactive` 或 `readonly` 方法创建的代理对象的原始对象。它可以帮助你绕过 Vue 的响应式系统直接操作原始数据。
- **使用场景**：主要用于调试、性能优化等场景下，当你需要访问原始对象而不是它的响应式代理版本时。
- **示例**：
  ```javascript
  import { reactive, toRaw } from 'vue';

  const state = reactive({
    name: 'Vue',
    version: 3
  });

  const originalState = toRaw(state);
  // originalState 是原始对象，不是响应式代理
  ```

### 📝 总结

- **`toRefs`**：用于将响应式对象的所有属性转化为独立的 `ref`，以便在解构或传递时保持其响应性。
- **`toRaw`**：用于获取一个响应式对象的原始对象，跳过 Vue 的响应式系统，适用于特定场景下的调试或优化。

希望这个简短的解释能帮助你在面试中清晰地回答关于 `toRefs` 和 `toRaw` 的区别！如果有更多问题或需要进一步解释，请随时告诉我。
